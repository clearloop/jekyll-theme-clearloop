1;95;0c# 冲突解决

冲突解决算法（也称为HAM）是 Gun 的所有功能的核心。这就是 Peers 最终达到同一状态的方式，以及离线编辑如何合并。系统中的每一个变化都经历了 HAM。

### Offline-First

通过强大的一致性来支持高可用性，即使机器完全脱机时也可以进行编辑（如没有网络连接的手机用户）。这立即排除了Paxos等团体共识算法 ）或Raft。

### Ordering

无论更新到达什么顺序（更新可交换性），都应达到相同的状态。

### Conflict Handling

当合并冲突发生时，每台机器应该独立选择相同的值（强大的最终一致性）。

### Implementation

```
(GunDB
    (Graph 
        (node 
            (value 
                (`key-value pairs)
            )
        )
    )
)
```

我们只要知道如何合并健值对，就可以合并节点，然后就可以合并图。

健值对是 `HAM` 原子，他不会合并基元，只会想办法把他们保留下来。这是棘手的部分，需要额外的元数据，称为`state`。`state` 用于确定更新的顺序，并且始终相对于接收它的机器（包括创建更新的机器）。


```
{
    "name": {
        "value": "Alice",
        "state": 10
    }
}
```

上面的是一个更新数据，若现在 Alice 的 `state` 为`8`。由于更新状态小于我们目前的状态，因此我们将其列为唯一历史重要，并且不要将其包含在我们的数据中。

> 可以使用 `diary-plugin` 来记录更新历史。

### Conflict

只有在完全相同的时间在完全相同的值上发生冲突时才使用词汇排序。在这个时候，Gun 将比较他们的字符串值JSON.stringify()，选择两者中较大的一个。

### States

这是危险的领域，如果处理不当可能会暴露应用程序漏洞。

例如，一个狡猾的用户提交了一个 `state` 为10亿的更新。

__但现在，除非他们的状态达到10亿加1，否则没有人会写入这个数据。__

HAM用`机器相对矢量`处理这个问题。当“10亿美元”更新进入时，HAM只会等到您的机器达到10亿美元的状态后再确认存在。如果更新未被确认，它永远不会将易失性存储器转移到磁盘上。我们称之为延期更新。

事实证明，这个向量可以计算任何线性值。数字，小数，字母，甚至是时间戳 - 这听起来应该是可怕的。时间戳很危险，因为：

系统时间并不总是向前移动（NTP更正）。
时钟同步并不总是可靠的。
有些时钟比其他时钟移动得更快。
您的系统时间可能会减少（特别是在考虑用户干预时）。

HAM的其中一个限制是不需要同步算法，包括NTP及其变体，因此无法假定准确的时钟。

但 HAM 并不关心你的时钟是否准确。它只关心机器的相对顺序，以及更新是否应该成为历史，当前状态的一部分，或者直到将来某个时刻才被忽略。

> 状态以此分为 `运行状态`, `历史状态`， `延迟状态`。

### 应用它

合并两个节点可以通过迭代更新的每个字段并决定选择哪个字段来完成：您已经拥有的字段或更新提议的字段。

如果更新节点具有源对象不包含的字段，则假定源节点的字段状态为-Infinity，这意味着您始终添加新字段。

对于图可以重复相同的过程，在更新图中的每个节点上迭代并将其与源进行合并。

您可以gun.js在名称下找到HAM实现function HAM。

### 注意事项

HAM不保证多进程线性化，因为在高可用性系统中，您不知道所有更新何时完成网络传播。相反，它保证了强大的最终一致性（SEC）。如果需要线性化，可以使用像Paxos这样的共识系统（牺牲可用性），或者使用链表，定向无环图（DAG）或其他方式将其明确构建到数据中。

+ 没有强一致性，线性化或可串行性。
+ 易受双重支出问题的影响。
